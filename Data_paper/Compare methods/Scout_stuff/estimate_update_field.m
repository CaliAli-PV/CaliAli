function [update] = estimate_update_field(...
    currentScale)
% ESTIMATE_UPDATE_FIELD Estimates the update field for current scale and iteration
%
% [update] = estimate_update_field(currentScale)
%
% Data used is contained in the data struct registration.
% See also REGISTRATION_EXECUTE
%
% INPUT ARGUMENTS
% currentScale              - Current scale
%
% OPTIONAL INPUT ARGUMENTS
% N/A
%
% OUTPUT ARGUMENTS
% update
%   displacementUpdate      - Estimated update field
%   certaintyUpdate         - Certainty related to the estimated update field
%   transformationMatrix    - Estimate transformation matrix (only if
%                             transformation model is set to translation or affine)

% Copyright (c) 2012  Daniel Forsberg
% danne.forsberg@outlook.com
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

global registration

switch registration.method
    case 'phase'
        [update] = phase_registration(...
            deformation(...
            registration.moving{currentScale + 1},...
            registration.displacementField,registration.interpolation), ...
            deformation(...
            registration.movingCertainty{currentScale + 1},...
            registration.displacementField,registration.interpolation), ...
            registration.fixed{currentScale + 1}, ...
            registration.fixedCertainty{currentScale + 1}, ...
            registration.transformationModel, ...
            currentScale);
    case 'optical-flow'
        if registration.multiModal
            [update] = optical_flow_registration(...
                deformation(...
                registration.moving{currentScale + 1},...
                registration.displacementField,registration.interpolation), ...
                registration.fixed{currentScale + 1},...
                registration.transformationModel,...
                registration.multiModal,...
                'numberOfChannels',registration.numberOfChannels(currentScale + 1));
        else
            [update] = optical_flow_registration(...
                deformation(...
                registration.moving{currentScale + 1},...
                registration.displacementField,registration.interpolation), ...
                registration.fixed{currentScale + 1},...
                registration.transformationModel,...
                registration.multiModal);
        end
    case 'polynomial-expansion'
        if registration.multiModal
            [update] = ...
                polynomial_expansion_registration(...
                deformation(...
                registration.moving{currentScale + 1},...
                registration.displacementField,registration.interpolation), ...
                registration.fixed{currentScale + 1},...
                registration.multiModal,...
                registration.transformationModel,...
                'numberOfChannels',registration.numberOfChannels(currentScale + 1),...
                'signalModel',registration.signalModel);
        else
            [update] = ...
                polynomial_expansion_registration(...
                deformation(...
                registration.moving{currentScale + 1},...
                registration.displacementField,registration.interpolation), ...
                registration.fixed{currentScale + 1},...
                registration.multiModal,...
                registration.transformationModel,...
                'signalModel',registration.signalModel);
        end
end